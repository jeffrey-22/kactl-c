\chapter{Various}

\section{Intervals}
	\kactlimport{IntervalContainer.h}
	\kactlimport{IntervalCover.h}
	\kactlimport{ConstantIntervals.h}

\section{Misc. algorithms}
	\kactlimport{TernarySearch.h}
	\kactlimport{LIS.h}

\section{Dynamic programming}
	\kactlimport{KnuthDP.h}
	\kactlimport{DivideAndConquerDP.h}

\section{Debugging tricks}
	\begin{itemize}
		\item \verb@signal(SIGSEGV, [](int) { _Exit(0); });@ converts segfaults into Wrong Answers.
			Similarly one can catch SIGABRT (assertion failures) and SIGFPE (zero divisions).
			\verb@_GLIBCXX_DEBUG@ failures generate SIGABRT (or SIGSEGV on gcc 5.4.0 apparently).
		\item \verb@feenableexcept(29);@ kills the program on NaNs (\texttt 1), 0-divs (\texttt 4), infinities (\texttt 8) and denormals (\texttt{16}).
	\end{itemize}

\section{Optimization tricks}
	\verb@__builtin_ia32_ldmxcsr(40896);@ disables denormals (which make floats 20x slower near their minimum value).
	\subsection{Bit hacks}
		\begin{itemize}
			\item \verb@x & -x@ is the least bit in \texttt{x}.
			\item \verb@for (int x = m; x; ) { --x &= m; ... }@ loops over all subset masks of \texttt{m} (except \texttt{m} itself).
			\item \verb@c = x&-x, r = x+c; (((r^x) >> 2)/c) | r@ is the next number after \texttt{x} with the same number of bits set.
			\item \verb@rep(b,0,K) rep(i,0,(1 << K))@ \\ \verb@  if (i & 1 << b) D[i] += D[i^(1 << b)];@ computes all sums of subsets.
		\end{itemize}
	\subsection{Pragmas}
		\begin{itemize}
			\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize loops and optimizes floating points better.
			\item \lstinline{#pragma GCC target ("avx2")} can double performance of vectorized code, but causes crashes on old machines.
			\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
		\end{itemize}
	\kactlimport{FastMod.h}
	\kactlimport{FastInput.h}
	% \kactlimport{BumpAllocator.h}
	% \kactlimport{SmallPtr.h}
	% \kactlimport{BumpAllocatorSTL.h}
	% \kactlimport{Unrolling.h}
	% \kactlimport{SIMD.h}
	% \kactlimport{Idk.h}
	\kactlimport{sos.h}
	\kactlimport{XorBasis.h}
	\kactlimport{Dijkstra.h}
\section{Techniques}
	\subsection{O(nk) Tree DP}
\begin{lstlisting}
function calc_dp (u):
	for each child v of u:
		calc_dp(v)
	dp[u]=[0]
	for each child v of u:
		temp=[0,0,...,0]
		for i in 0..length(dp[u])-1:
			for j in in 0..length(dp[v])-1:
				if i+j<K:
					# calculate something 
					# typically based on dp[u][i] and dp[v][j]
					# commonly assign to temp[i + j]
		pop elements from temp until length(temp)<=K
		dp[u]=temp
\end{lstlisting}
\subsection{$O(nk)$ Tree DP}
Assume you have $n$ rocks with nonnegative integer weights $a_1,a_2,\cdots,a_n$ such that $a_1+a_2+\cdots+a_n=m$
\begin{itemize}
\item You want to find out if there is a way to choose some rocks such that their total weight is $w$
\item Suppose there are three rocks with equal weights $a,a,a$
\item Notice that it doesn't make any difference if we replace these three rocks with two rocks with weights $a,2a$
\item We can repeat this process of replacing until there are at most two rocks of each weight. The sum of weights is still $m$,
so there can be only $O(\sqrt{m})$ rocks. Now you can use a classical DP algorithm but with only $O(\sqrt{m})$
elements, which can be lead to a better complexity in many cases.
\end{itemize}
This trick mostly comes up when the $a_1,a_2,\cdots,a_n$ form a partition of some kind. 
For example, maybe they represent connected components of a graph.